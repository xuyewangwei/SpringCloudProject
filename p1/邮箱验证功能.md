两个流程：
## 服务端
* 前段表单，提交用户输入的邮箱
* 生成，发送验证码
* 用户输入验证码
* 验证并完成注册

# 数据库表设计
以下属性都要求非空
id:主键
email:
code:验证码
type:类型，创建或重置
expired_at: Timstamp
created_at:
used:boolean
Primary key(id)

Index idx_email(email), //创建索引
Index idx_code(code),
Index idx_expired_at(expired_at)

# 接下来是最重磅的代码部分！！！
先介绍一些注解：
@Service
@Service 注解可以将一个类声明为业务逻辑组件，并将其对象存入 Spring 容器中。
在控制器类中，通过注入该组件的实例，即可调用其中的方法。
ex:
```
@RestController
public class OrderController {

    @Autowired
    private OrderService orderService;//自动装配以使用

    @PostMapping("/orders")//post创建订单
    public Order createOrder(@RequestBody Order order) {
        return orderService.createOrder(order);
    }

    @GetMapping("/orders/{orderId}")//get查询订单
    public Order getOrderDetails(@PathVariable String orderId) {
        return orderService.getOrderDetails(orderId);
    }
}
```
这里复习一下这些层级：
* controller接口控制层，这里直接接受前端发送的http请求，如果和数据库有交互，就转给service,没有的直接直接返回response
* service业务层，负责对接controller与dao层，使controller层可方便地调用集成在service层的数据库操作
* dao数据访问层，找到对应的交互方法
* domain数据表对象层：将数据表抽象为一个对象，同步对象的值和数据表中的值
* * controller:
  * service:
  * dao:
* view视图层，和控制层结合紧密，主要负责前台jsp页面的显示

好，接下来是value注入
@Value
通过@Value将外部的值动态注入到Bean中，使用的情况有：
注入普通字符串
注入操作系统属性
注入表达式结果
注入其他Bean属性：注入beanInject对象的属性another
注入文件资源
注入URL资源
